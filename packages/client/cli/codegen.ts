import process from 'process';
import path from 'path';
import fs from 'fs';
import { format } from 'prettier';
import {
  DB,
  Migration,
  AttributeDefinition,
  CollectionsDefinition,
  CollectionDefinition,
} from '@triplit/db';
import { triplesToObject } from 'packages/db/src/utils';

interface MigrationFile {
  filename: string;
  migration: Migration;
}

export async function codegen(version?: number) {
  const cwd = process.cwd();
  const triplitDir = path.join(cwd, 'triplit');
  const migrationsDir = path.join(triplitDir, 'migrations');

  const migrationFiles = fs
    .readdirSync(migrationsDir)
    .map<MigrationFile>((file) => ({
      migration: JSON.parse(
        fs.readFileSync(`${migrationsDir}/${file}`, 'utf8')
      ) as Migration,
      filename: file,
    }))
    .filter((mf) => version == undefined || mf.migration.version <= version)
    .sort((a, b) => a.migration.version - b.migration.version);

  const db = new DB({ migrations: migrationFiles.map((mf) => mf.migration) });
  await db.ensureMigrated;
  const schemaTriples = await db.tripleStore.readMetadataTuples('_schema');
  const schemaData = triplesToObject<any>(schemaTriples);
  const metadata = schemaData._schema?.collections || {};
  const schemaContent = collectionsDefinitionToFileContent(metadata);

  const migrationImports = migrationFiles.map((mf) => {
    const name = `migration_${mf.migration.version}`;
    return { file: mf.filename, name };
  });

  // Write to schema file
  const fileName = path.join(triplitDir, 'schema.ts');
  const fileContent =
    `
/**
 * This file is auto-generated by the Triplit CLI for migration ${version}.
 * You should not edit this file directly instead run migrations to update.
 */ 

import { Migration, CollectionRules } from '@triplit/db';
${migrationImports
  .map((m) => `import ${m.name} from './migrations/${m.file}';`)
  .join('\n')}
import { Schema as S } from '@triplit/client';
export const migrations = [
  ${migrationImports.map((m) => `${m.name} as Migration`).join(',\n\t')}
];
const schema = ${schemaContent};
export type Schema = typeof schema;
      `.trim() + '\n';

  fs.mkdirSync(path.dirname(fileName), { recursive: true });

  //use prettier as a fallback for formatting
  const formatted = format(fileContent, { parser: 'typescript' });
  fs.writeFile(fileName, formatted, 'utf8', (err) => {
    if (err) throw err;
    console.log(`New schema has been saved at ${fileName}`);
  });
}

// Generate a string representation of the schema that can be written to a file
const indentation = '  ';
export function collectionsDefinitionToFileContent(
  collectionsDefinition: CollectionsDefinition,
  indent = indentation
) {
  let result = '{\n';
  for (let collectionKey in collectionsDefinition) {
    result += indent;
    result += `${collectionKey}: {\n`;
    const { attributes, rules } = collectionsDefinition[collectionKey];
    result += generateAttributesSection(attributes, indent + indentation);
    result += generateRulesSection(rules, indent + indentation);
    result += indent + '},\n';
  }
  return result + indent.slice(0, -2) + '}';
}

function generateAttributesSection(
  attributes: CollectionDefinition['attributes'],
  indent: string
) {
  let result = '';
  result += indent + 'attributes: S.Schema({\n';
  for (const path in attributes) {
    const itemInfo = attributes[path];
    result += generateAttributeSchema([path], itemInfo, indent + indentation);
  }
  result += indent + '}),\n';
  return result;
}

function generateRulesSection(
  rules: CollectionDefinition['rules'],
  indent: string
) {
  let result = '';
  if (rules) {
    result +=
      indent +
      `rules: ${JSON.stringify(rules, null, 2)
        .split('\n')
        .join(`\n${indent}`)}`;
    result += ' as CollectionRules<any>,\n';
  }

  return result;
}

function generateAttributeSchema(
  path: string[],
  schemaItem: AttributeDefinition,
  indent: string
) {
  if (path.length === 0) return schemaItemToString(schemaItem);
  if (path.length === 1)
    return indent + `${path[0]}: ${schemaItemToString(schemaItem)},\n`;
  let result = '';
  const [head, ...tail] = path;
  result += indent + `${head}: {\n`;
  result += generateAttributeSchema(tail, schemaItem, indent + indentation);
  result += indent + '},\n';
  return result;
}

function schemaItemToString(schemaItem: AttributeDefinition) {
  const { type } = schemaItem;
  if (type === 'string') return 'S.string()';
  if (type === 'boolean') return 'S.Boolean()';
  if (type === 'number') return 'S.number()';
  if (type === 'set_string') return 'S.Set(S.string())';
  if (type === 'set_number') return 'S.Set(S.number())';
  throw new Error(`Invalid type: ${type}`);
}

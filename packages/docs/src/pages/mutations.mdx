import { Callout } from 'nextra-theme-docs';

# Mutations

Increment the odometer by 1 mile.

## Defining mutations

The trilpit client provides two methods for mutating data: `insert` and `update`.

### Insert

Insert inserts a new record into a collection. For example:

```typescript
await client.insert('employee', { name: 'Philip Fry' }, 1);
```

Providing an id is optional. If no id is provided, one will be generated for you.

### Update

Update updates an existing record in a collection. For example:

```typescript
await client.update('employee', 1, (mutation) => {
  mutation.attribute(['name']).set('Philip J. Fry');
});
```

If possible, `update` will look at the schema you have provided to provide proper methods for interacting with you data. If no schema is provided, all fields are treated as registers.

Registers have the following API:
`set(value: any)`

Sets have the following API:
`add(value: any)`
`remove(value: any)`

## Transactions

Transactions are a way to group multiple mutations into a single atomic operation. If any part of the mutations fail, the entire transaction is rolled back.

A transaction can be created by calling `client.transact()`. For example:

```typescript
await client.transact((tx) => {
  await tx.insert('employee', { name: 'Philip J. Fry' }, 1);
  await tx.insert('employee', { name: 'Turanga Leela' }, 2);
  await tx.insert('employee', { name: 'Bender Bending Rodriguez' }, 3);
});
```

If you decide you need to abort a transaction, you can call `cancel` inside your transaction. For example:

```typescript
await client.transact((tx) => {
  await tx.insert('employee', { name: 'Hermes Conrad' }, 4);
  await tx.cancel();
});
```

## Error and success handling

Mutations are first run on Triplit's local cache "optimistically", returning a promise. If the optimistic mutation is successful, the promise will resolve with the id of the transaction. If the optimistic mutation fails, the promise will reject with an error. So you can handle optimisitc updates with standard promise handling. For example:

```typescript
try {
  const txId = await client.insert('employee', { name: 'Philip Fry' }, 1);
  // Optimistic update succeeded
} catch (e) {
  // Optimistic update failed
}
```

If syncing is enabled, mutations will then be applied to the server. To react to a transaction successfully running or failing on the server, you can pass a callback to `client.syncEngine.onTxCommit(txId, callback)` or `client.syncEngine.onTxFailure(txId, callback)`. The client also provides methods for helping you manage what should happen to your data if a transaction fails on the server. `client.syncEngine.retry(txId)` will retry a transaction with the id `txId`. `client.syncEngine.rollback(txId)` will rollback a transaction with the id `txId`, removing it from the local cache. For example:

```typescript
const txId = await client.insert('employee', { name: 'Philip Fry' }, 1);
client.syncEngine.onTxCommit(txId, () => {
  // Transaction succeeded on the server
});
client.syncEngine.onTxFailure(txId, (e) => {
  // Transaction failed on the server
  // shouldRetry is a boolean you define
  if (shouldRetry) {
    client.syncEngine.retry(txId);
  } else {
    client.syncEngine.rollback(txId);
  }
});
```

Tripit's API attempts to give you the flexibility to handle errors in various ways. For example, you could choose to retry a transaction a certain number of times before rolling it back. Or you could choose to retry a transaction only if it failed due to a network error.
